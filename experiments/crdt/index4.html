<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32'><rect width='100%' height='100%' fill='red'/></svg>"
    />

    <title>JSON-Joy File List Merger</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB"
      crossorigin="anonymous"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/jsoneditor/10.1.0/jsoneditor.min.css"
      rel="stylesheet"
      type="text/css"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div class="container">
      <h1 class="mt-3">JSON-Joy File List Merger</h1>
      <div class="alert alert-info mt-3" role="alert">
        <strong>Status:</strong> <span id="connectionStatus">Disconnected</span> | <strong>Peers:</strong>
        <span id="peerCount">0</span> | <strong>Files:</strong> <span id="fileCount">0</span>
      </div>

      <form id="roomForm">
        <div class="mb-3">
          <label for="roomId" class="form-label">Room ID (share this with others to collaborate)</label>
          <input type="text" class="form-control" id="roomId" placeholder="Room ID" />
        </div>
        <button type="submit" class="btn btn-primary mb-3">Change Room ID</button>
      </form>

      <div class="btn-group mb-3" role="group">
        <button type="button" class="btn btn-primary pick-file">Pick Files</button>
        <button type="button" class="btn btn-danger clear-data">Clear All Data</button>
      </div>

      <div id="jsoneditorDiv" style="height: 600px; margin-top: 20px; border: 1px solid #ddd"></div>
    </div>

    <script type="module">
      import * as Y from 'yjs';
      import { WebrtcProvider } from 'y-webrtc';
      import localforage from 'localforage';
      import JSONEditor from 'jsoneditor';

      // Global variables
      const doc1 = new Y.Doc(); // Create only once
      let ymap1 = doc1.getMap('files');
      let provider = null;
      let jsonEditor = null;

      // Initialize JSON Editor
      const initializeEditor = () => {
        const container = document.getElementById('jsoneditorDiv');
        const options = {
          mode: 'tree',
          modes: ['tree', 'view', 'form', 'code', 'text'],
          onChange: () => {
            // Optional: You could sync manual edits back to Yjs here
            // This works for all modes
            try {
              const json = jsonEditor.get();
              console.log('JSON manually edited', json);
            } catch (e) {
              // Invalid JSON in code/text mode
              console.log('Editor content changed');
            }
          },
        };

        if (jsonEditor) {
          jsonEditor.destroy();
        }

        const data = generateJSONTree(ymap1);
        jsonEditor = new JSONEditor(container, options, data);
        updateStats();
      };

      // Update connection stats
      const updateStats = () => {
        document.getElementById('fileCount').textContent = ymap1.size;
        if (provider) {
          document.getElementById('peerCount').textContent = provider.connected
            ? provider.room?.webrtcConns?.size || 0
            : 0;
        }
      };

      // Generate JSON tree from Yjs map
      const generateJSONTree = ymap => {
        const nodes = {};
        ymap.forEach((value, key) => {
          nodes[key] = { ...value, children: [] };
        });

        const roots = [];

        Object.values(nodes).forEach(node => {
          if (node.parentId && nodes[node.parentId]) {
            nodes[node.parentId].children.push(node);
          } else {
            roots.push(node);
          }
        });

        function cleanNode(node) {
          const { objectId, parentId, children, ...rest } = node;
          const cleaned = {
            ...(node.type === 'file' ? { _id: objectId } : {}),
            ...rest,
          };

          if (node.type === 'directory') {
            cleaned.children = node.children.map(cleanNode);
          }
          return cleaned;
        }

        return roots.map(cleanNode);
      };

      // Utility functions
      const generateUUID = () => {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
          (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16),
        );
      };

      const generateEncKey = () => {
        return Array.from(crypto.getRandomValues(new Uint8Array(32)))
          .map(b => b.toString(16).padStart(2, '0'))
          .join('');
      };

      const createEntry = (objectId, parentId, name, size, type) => {
        return {
          objectId: objectId,
          parentId: parentId || null,
          name: name,
          encKey: generateEncKey(),
          size: size || 0,
          type: type || 'file',
        };
      };

      // Get or set room key
      const getOrSetRoomKey = async () => {
        let roomKeyValue = null;
        try {
          roomKeyValue = await localforage.getItem('roomkey');
          if (!roomKeyValue) {
            roomKeyValue = [...crypto.getRandomValues(new Uint8Array(3))]
              .map(m => ('0' + m.toString(16)).slice(-2))
              .join('');
            await localforage.setItem('roomkey', roomKeyValue);
          }
          console.log('Room key is:', roomKeyValue);
          document.getElementById('roomId').value = roomKeyValue;
        } catch (err) {
          console.error('Error getting/setting room key:', err);
        }
        return roomKeyValue;
      };

      // Create WebRTC provider
      const createProvider = roomId => {
        if (provider) {
          provider.disconnect();
          provider.destroy();
        }

        const roomName = 'room_' + roomId;
        provider = new WebrtcProvider(roomName, doc1, {
          signaling: ['wss://yjs-provider-test-1.jensenwtfwtf.workers.dev/yjs/ws/1'],
          password: null,
          filterBcConns: true,
        });

        // Set up event listeners
        provider.on('synced', synced => {
          console.log('WebRTC synced:', synced);
          document.getElementById('connectionStatus').textContent = synced ? 'Synced' : 'Syncing...';
          if (synced) {
            // Update editor when synced
            if (jsonEditor) {
              jsonEditor.update(generateJSONTree(ymap1));
            } else {
              initializeEditor();
            }
            updateStats();
          }
        });

        provider.on('status', status => {
          console.log('WebRTC status changed:', status);
          document.getElementById('connectionStatus').textContent = status.connected ? 'Connected' : 'Disconnected';
        });

        provider.on('peers', event => {
          console.log('Peers changed:', event);
          updateStats();
        });

        return provider;
      };

      // Listen for Yjs document updates
      doc1.on('update', (update, origin) => {
        console.log('Yjs document updated from:', origin);
        // Update the JSON editor with new data
        if (jsonEditor) {
          const newData = generateJSONTree(ymap1);
          jsonEditor.update(newData);
        } else {
          initializeEditor();
        }
        updateStats();
      });

      // Initialize
      const roomKey = await getOrSetRoomKey();
      provider = createProvider(roomKey);

      // Initialize editor even if empty
      initializeEditor();

      // Form submit handler
      document.getElementById('roomForm').addEventListener('submit', async event => {
        event.preventDefault();
        const newRoomId = document.getElementById('roomId').value;
        if (newRoomId) {
          await localforage.setItem('roomkey', newRoomId);
          console.log('Room ID changed to:', newRoomId);

          // Clear current data (don't create new doc)
          ymap1.clear();

          // Disconnect old provider
          if (provider) {
            provider.disconnect();
            provider.destroy();
          }

          // Create new provider with same doc
          provider = createProvider(newRoomId);

          // Reset editor
          initializeEditor();
        }
      });

      // Pick files handler
      document.querySelector('.pick-file').onclick = async () => {
        try {
          const dirHandle = await window.showDirectoryPicker();

          async function processDirectory(dirHandle, parentId = null, path = '') {
            const dirId = generateUUID();
            const entry = createEntry(dirId, parentId, dirHandle.name, 0, 'directory');
            ymap1.set(dirId, entry);

            for await (const handle of dirHandle.values()) {
              if (handle.kind === 'file') {
                const file = await handle.getFile();
                const fileId = generateUUID();
                const fileEntry = createEntry(fileId, dirId, handle.name, file.size, 'file');
                ymap1.set(fileId, fileEntry);
              } else if (handle.kind === 'directory') {
                await processDirectory(handle, dirId);
              }
            }
          }

          await processDirectory(dirHandle, null);
          console.log('Files loaded:', ymap1.size, generateJSONTree(ymap1));
        } catch (err) {
          console.error('Directory selection cancelled or error:', err);
        }
      };

      // Clear data handler
      document.querySelector('.clear-data').onclick = () => {
        if (confirm('Are you sure you want to clear all data?')) {
          ymap1.clear();
          console.log('All data cleared');
        }
      };
    </script>
  </body>
</html>
